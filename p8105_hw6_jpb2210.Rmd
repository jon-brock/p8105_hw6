---
title: "Data Science - Homework #6"
author: "Jon Brock - JPB2210"
output: 
    github_document:
        toc: TRUE
        toc_depth: 2
---

```{r load packages, message = FALSE}
library(tidyverse)
library(modelr)
```

***

## Problem #1
###### (*45 points*)
##### *Working with linear models*  

I reviewed each vector to determine what vector type each one should be when imported. There is a majority of integer values, so the `.default` value for non-specified vectors applies as such. I specified `babysex`, `frace`, `malform`, and `mrace` as `<fct>` vectors; `gaweeks`, `ppbmi`, and `smoken` are specified as `<dbl>` vectors. I will further tidy--relevel and relabel--my specified `<fct>` vectors in subsequent code.  

```{r load and tidy data}
bw_df <- read_csv("./data/birthweight.csv",
                  col_names = TRUE,
                  col_types = cols(
                      .default = col_integer(),
                      babysex = col_factor(),
                      frace = col_factor(),
                      gaweeks = col_double(),
                      malform = col_factor(),
                      mrace = col_factor(),
                      ppbmi = col_double(),
                      smoken = col_double()
                      )
                  )

bw_df
```


It is rather tedious to check for `NA` values within individual vectors one at a time. So, instead, I decided to check all vectors at once by using a "soft-deprecated" `dplyr` function (`funs()`) to summarize all of the `NA` observations within each vector in my data frame.  

```{r checking all columns for na values, warning = FALSE}
options(tibble.width = Inf)

bw_df %>% 
    select(everything()) %>% 
    summarize_all(funs(sum(is.na(.))))
```

The output shows that we have `0` observations of `NA` in all of our vectors. We're good to go!  

```{r variable renaming and recoding}
bw_df <- 
    bw_df %>% 
    mutate(
        baby_sex = recode(babysex, "1" = "male", "2" = "female"),
        baby_head_cm = bhead,
        baby_length_cm = blength,
        baby_birthweight_grams = bwt,
        mother_weight_grams = delwt * 453.492,
        family_income = fincome,
        father_race = recode(frace, "1" = "white", "2" = "black", "3" = "asian", "4" = "p_rican", "8" = "other", "9" = "unknown"),
        gestation_age_wks = gaweeks,
        malformations_present = recode(malform, "0" = "absent", "1" = "present"),
        mother_menarche_age = menarche,
        mother_height_cm = mheight * 2.54,
        mother_delivery_age = momage,
        mother_race = recode(mrace, "1" = "white", "2" = "black", "3" = "asian", "4" = "p_rican", "8" = "other"),
        number_prior_births = parity,
        number_prior_low_bwt_babies = pnumlbw,
        number_prior_small_ga_babies = pnumsga,
        mother_pre_pregnancy_bmi = ppbmi,
        mother_pre_pregnancy_weight_grams = ppwt * 453.492,
        avg_number_cigs_per_day = smoken,
        mother_pregnancy_weight_gain_grams = wtgain * 453.492) %>% 
    select(c(baby_sex:mother_pregnancy_weight_gain_grams))

print(bw_df)
```

We have successfully recoded and renamed all `20` of our variables, and dropped the original `20` for lack of further need.  It's important to note that variable  measurements were incongruent in terms of scale -- both metric and imperial were used. To correct for this I made the necessary conversions so that all measurements are metric (i.e., weight = grams, height/length = centimeters).  

```{r fitting a linear model}
jon_fit <- lm(baby_birthweight_grams ~ 
                  gestation_age_wks +
                  mother_weight_grams +
                  number_prior_low_bwt_babies +
                  avg_number_cigs_per_day,
              data = bw_df)

broom::tidy(jon_fit) %>% 
    knitr::kable()
```

```{r plotting of model, predictions, and residuals, warning = FALSE, fig.align = "center"}
bw_df %>% 
    add_predictions(jon_fit) %>% 
    add_residuals(jon_fit) %>% 
    ggplot(aes(x = gestation_age_wks, y = baby_birthweight_grams)) + 
        geom_point() + 
        stat_smooth(method = "lm")
        #geom_line(aes(y = pred), color = "red")
```

***  

## Problem #2
###### (*35 points*)
##### *Bootstrapping*  

```{r pre-specified data import code, message = FALSE}
weather_df = 
  rnoaa::meteo_pull_monitors(
    c("USW00094728"),
    var = c("PRCP", "TMIN", "TMAX"), 
    date_min = "2017-01-01",
    date_max = "2017-12-31") %>%
  mutate(
    name = recode(id, USW00094728 = "CentralPark_NY"),
    tmin = tmin / 10,
    tmax = tmax / 10) %>%
  select(name, id, everything())

weather_df
```

```{r fit linear model}

boot_sample = function(df) {
  sample_frac(df, replace = TRUE)
}

fit = lm(tmax ~ tmin, data = weather_df)
      
lm_output <- tibble(
    r_square = broom::glance(fit) %>% summarize(r.squared),
    logb0b1 = broom::tidy(fit) %>% summarize(log_b0xb1 = log((estimate[1]*estimate[2])))
)
    
knitr::kable(lm_output)
    
    r_square_ci = quantile(lm_output[1], c(0.025, 0.975))
    logb0b1_ci = quantile(lm_output[2], c(0.025, 0.975))



weather_df %>% 
  modelr::bootstrap(n = 100) %>% 
  mutate(
    models = map(strap, ~lm(tmax ~ tmin, data = .x)),
    tidy_models = map(models, broom::tidy),
    glance_models = map(models, broom::glance)) %>% 
  unnest(tidy_models, glance_models) %>% 
  select(.id, term, estimate, r.squared) %>% 
  pivot_wider(
      names_from = term,
      values_from = estimate) %>% 
  rename(
      beta_0 = `(Intercept)`,
      beta_1 = tmin) %>% 
  

    
  group_by(term) %>% 

  summarize(
      r_square = r.squared,
      log_b0xb1 = log((estimate[1]*estimate[2]))
)











boot_straps = 
  tibble(
    strap_number = 1:5000,
    strap_sample = rerun(5000, boot_sample(weather_df),
    r2 = broom::glance(fit) %>% summarize(r.squared),
    logb0b1 = broom::tidy(fit) %>% summarize(log_b0xb1 = log((estimate[1]*estimate[2]))))
  )


test_mapping <- map(weather_df, boot_sample)

bs_weather <- bootstrap(weather_df, 10, id = ".id")





# Need to create a function that will generate the log(beta0 * beta1)    

fit %>%
    ggplot(aes(x = tmin, y = tmax)) + geom_point() + stat_smooth(method = "lm")



```



```{r generate bootstrap function, eval = FALSE}
boot_sample = function(df) {
  
    sample_frac(df, replace = TRUE)
    
    for (i in 1:5000) {
    
    weather_lm[[i]] <- lm(tmax ~ tmin, data = df)
    
    }
}
```

```{r eval = FALSE}
set.seed(1) #remove after review

boot_sample(weather_df) %>% 
  ggplot(aes(x = date, y = tmax)) + 
  geom_point(alpha = .5) +
  stat_smooth(method = "lm")
```





***



```{r eval = FALSE}

```

```{r eval = FALSE}
boot_straps <- 
    weather_df %>% 
    bootstrap(n = 5000)

########

boot_straps %>% 
  modelr::bootstrap(n = 5000) %>% 
  mutate(
    models = map(strap, ~lm(tmax ~ tmin, data = .x) ),
    results = map(models, broom::tidy)) %>% 
  select(-strap, -models) %>% 
  unnest(results) %>% 
  group_by(term) %>% 
  summarize(boot_se = sd(estimate))
```

***  

## Return of the Bonus Content  
